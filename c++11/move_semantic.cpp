/**
 * @file move_semantic.cpp
 * @author Grigory Okhmak (ohmak88@yandex.ru)
 * @details 
 * Начиная со стандарта С++11 в язык была добавлена возможность создавать ссылки на r-значения, т.е.
 * на такие, которые могут находиться только в правой части выражения. Типичными r-значениями являются
 * литералы и временно создаваемые объекты, например
 * @code
 * int var = 42; // Значение '42' является литералом и в данном выражении это r-значение.
 * std::string str = std::string("Hello");  // Временно создаваемая строка, которая копируется в str, является r-значением.
 * @endcode 
 * С++ программистам известно, что ссылка это способ получения доступа к объекту по другому имени, но до создания
 * ссылки этот объект уже должен быть инициализирован.
 * @code
 * int var = 123;
 * int& reference = var;
 * 
 * // Однако так делать нельзя
 * int& var1 = 999;     // ошибка
 * 
 * // Тем не менее, константным ссылкам всегда можно было присваивать r-значения. Этим пользуются для передачи функции объектов по ссылке.
 * int const& constRef = 555;
 * @endcode
 * Чтобы создать ссылку на r-значение, нужно использовать новую семантику с двойным амперсандом
 * @code
 * int&& var = 124;
 * int k = 125;
 * int&& var1 = k;
 * @endcode
 * Ссылки на r-значения используются для реализации семантики перемещения, когда память таких объектов не копируется,
 * а перемещается для дальнейшего использования, что позволяет сэкономить процессорное время и ресурсы памяти на выделение
 * и копирование.
 * @version 0.1
 * @date 2019-02-05
 * 
 * @copyright GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007
 * 
 */

#include <iostream>
#include <vector>

/**
 * @brief 
 * В этом примере мы передаем вектор по константной ссылке. Если функция не модифицирует вектор, то это хорошее решение. 
 * Однако, если нам нужны операции над вектором, то нам нужно создать его локальную копию, тратя память и
 * время на копирование.
 * @param input 
 */
void process_vec(const std::vector<int>& input) {
    std::cout << __FUNCTION__ << " (copy)" << std::endl;
    std::vector<int> v(input);
    // и выполняем какие-нибудь операции с локальной копией
    v.push_back(13);
}

/**
 * @brief
 * В этом примере мы передаем вектор по сслыке на r-значение. Мы предполагаем, что передаваемый вектор
 * можно редактировать. Мы можем модифицировать оригинал не прибегая к копированию.
 * @param input 
 */
void process_vec(std::vector<int>&& input) {
    std::cout << __FUNCTION__ << " (move)" << std::endl;
    input.push_back(1);
    input.push_back(2);
    input.push_back(3);
}

/**
 * @brief 
 * Семантика перемещения обычно используется в так называемых конструкторах перемещения. Одним из
 * примеров применения конструкторов перемещения являются уникальные умные указатели, которые в один
 * момент времени могут хранить один адрес памяти, который нельзя копировать между объектами. В таком умном указателе
 * конструктор копирования и оператор равно заблокированы, но имеется перемещающий конструктор, с помощью которого
 * права на указатель передается от объекта к объекту. 
 * Таким образом, с помощью семантики перемещения реализуется так называемая передача прав на владение объектом.
 * 
 * Другим примером применения семантики перемещения является работа с большими массивами, которые
 * не хотелось бы копировать.
 */
class Example {
    int *m_data;
    enum consts {
        SIZE = 1000000
    };
public:
    Example()
    : m_data(new int[SIZE]) {
        /*
         * В данном конструкторе выделяется большое количество памяти.
         */
    }
    virtual ~Example() {
        delete [] m_data;
    }

    /*
     * Ниже реализован обычный копирующий конструктор. Он копирует
     * данные из объекта, переданного по ссылке на l-значение.
     */
    Example(const Example& ref)
    : m_data(new int[SIZE])
    {
        std::copy(ref.m_data, ref.m_data + SIZE, m_data);
    }

    /*
     * Ниже реализован перемещающий конструктор, который забирает данные у объекта
     * переданного по ссылке без копирования.
     */
    Example(Example&& ref)
    : m_data(ref.m_data)
    {
        ref.m_data = nullptr;   // мы "отбираем" права на данные у объекта, на основе которого конструируется данный
    }

    bool check() {
        return m_data != nullptr;
    }
};

#define CHECK(_obj_, _name_)\
    std::cout << "The object " << _name_ << (_obj_.check() ? " is initialized" : " is not initialized") << std::endl

/**
 * @brief 
 * Следует также рассмотреть нюанс относительно шаблонных функций. В таком виде шаблонной функции можно передавать
 * как ссылки на l-значения, так и ссылки на r-значения. Следует помнить когда и в какой ситуации механизм выведения
 * типа применяет тот или иной тип.
 * 
 * Механизм выведения типа интерпретирует переданный тип как ссылку на l-значение, если передана ссылка на l-значение,
 * и на обычный не ссылочный тип, если передано r-значение.
 * @tparam T 
 * @param t 
 */
template<typename T>
void tfunc(T&& t) {
    std::cout << t << std::endl;
}

int main(int argc, char* argv[]) {
    // 1
    // Вызываем версию функции по ссылке на r-значение. Этот вызов по сути бессмысленный, так как мы не можем получить конечный результат.
    process_vec(std::vector<int>());
    // 2
    std::vector<int> v;
    process_vec(v);     // Вызываем версию функции по ссылке на l-значение
    // 3
    process_vec(std::move(v));      // Вызываем версию функции по ссылке на r-значение
    /* Примачение:
     * Обратите внимание, что для работы move семантики необходимо явно привести объект к 
     * ссылке на r-значение. Для этого вы можете воспользоваться функцией стандартной библиотеки std::move(),
     * либо явно привести к ссылке на r-значение, как показано ниже.
     */
    process_vec(static_cast<std::vector<int>&&>(v));    // Такая запись кажется громоздкой, поэтому удобнее использовать std::move()
    for (auto entry : v) {
        std::cout << "v: " << entry << std::endl;
    }
    // 4
    // В этом примере мы реализуем семантику перемещения в перемещающем конструкторе.
    Example source;
    CHECK(source, "\"source\"");
    Example target(std::move(source));
    CHECK(source, "\"source\"");
    CHECK(target, "\"target\"");
    // 5
    // Во всех трех случаях тип выводится из r-значения.
    tfunc(42);
    tfunc(3.1415);
    tfunc("aaa");
    // В следующем случае будет выведена ссылка на l-значение. 
    int var = 1234;
    tfunc(var);

    return 0;
}