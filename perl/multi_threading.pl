#!/usr/bin/perl

use strict;

#
# Следующий пакет позволяет работать с потоками. Убедитесь, что ваша версия perl
# была собрана с поддержкой многопоточности. Для этого достаточно в командной оболочке
# ввести:
#   perl -e 'use threads'
# В случае успеха, ничего не должно быть выведено.
# 
use threads;
use threads::shared;
use Thread::Queue;
use Thread::Semaphore;

sub get_time () {
    my($arg) = @_;
    print "Thread ", $arg, ": time = ", time(), "\n";
    sleep 1;
}

#
# Чтобы создать поток, необходимо вызвать конструктор класса
# threads, в который нужно передать указатель на функцию, которая
# будет запущена в потоке и аргументы функции.
#
# threads->new(\&get_time, 'get_time: 1');
# threads->new(\&get_time, 'get_time: 2');
# threads->new(\&get_time, 'get_time: 3');
#
# В perl, основной поток, запускающий остальные, отвечает за их сопровождение.
# В самом простом случае, основной поток должен дождаться, пока потоки,
# которые он породил, не завершат свою работу. Основной поток также может отсоединиться
# от порожденного им потока и продолжать свою работу дальше.
#
# В нашем примере, где потока 3, сложно использовать одну из этих стратегий без дополнительных
# улучшений. Во-первых, мы не можем по очереди дожидаться каждый поток, так как по сути
# нет никакой многопоточности. Во-вторых, мы не можем отсоединниться от всех потоков, потому что
# в этом случае мы не можем получить конечный результат. Также мы не можем отсоединиться от первых
# двух потоков и дождаться последнего, потому что, в общем случае, нет никаких гарантий, что
# последний поток завершится позже первых двух.
#
# Часто на практике потоки открывают и заносят их дескрипторы в массив. Затем основной
# поток может заняться своими делами, а затем в конце по очереди присоединяться
# к каждому потоку.
#
my @threads;

for my $i (1..3) {
    push @threads, threads->create(\&get_time, "get_time: $i");
}
#
# ... основной поток может сделать еще что-нибудь полезное ...
#
# Ожидаем порожденные потоки
for my $thread (@threads) {
    $thread->join();
}

# Между потоками можно обмениваться данными. Для этого необходимо подключить пакет shared.
# Разделяемая переменная должна быть сопровождена модификатором shared, либо нужно вызвать
# функцию share, чтобы сделать ее разделяемой.

sub accumulate_plus_1() {
    my($arg) = @_;
    ++$$arg;
}

# 1
my $shared_var_1 : shared = 0;
# 2
my $shared_var_2 = 1;
share $shared_var_2;

@threads = ();
for my $i (1..3) {
    push @threads, threads->create(\&accumulate_plus_1, \$shared_var_1);
}

for my $thread (@threads) {
    $thread->join();
}

print "value=$shared_var_1\n";

#
# Следует помнить, что потоки могут работать вместе только над разделяемыми переменными. При
# попытке взаимодействовать с переменной, локальной для потока, из другого потока программа аварийно
# завершится. Допустимо безопасно копировать значения из неразделяемых переменных в разделяемые.
# Также допустимо обмениваться разделяемыми ссылками.
#

#
# Отсоединенные потоки в perl не могут быть больше присоединены к основному
# и будут работать параллельно с основным, пока их код не кончится.
# Такие потоки обычно используют в модели, когда сервер создает по потоку для
# каждого клиента. Если основной поток завершится раньше отсоединенных,
# то мы никак не сможем узнать, как они завершились без дополнительных системных
# инструментов.
#

sub detached_thread() {
    print "Hello, World!\n";
    sleep 1;
}
sub detached_thread_1() {
    # Поток может сам отсоединиться, если захочет
    print "Goodbye, World!\n";
    sleep 1;
}

threads->create(\&detached_thread)->detach();
threads->new(\&detached_thread_1)->detach();

sleep 2;

#
# Как и в других языках, поддерживающих многопоточность, perl также имеет
# механизмы синхронизации при обращении к разделяемым переменным. 
# Сюда входят:
#  - простой мьютекс (блокировка);
#  - синхронизированная очередь;
#  - семафор;
#  - условная переменная.
#
# МЬЮТЕКС
# Для контроля доступа к разделяемой переменной используется функция lock(),
# которая аналогична захваченному мьютексу. Этой переменной передается
# разделяемая переменная, которой поток будет пользоваться единолично.
# В perl действие функции lock() ограничено блоком из фигурных скобок, в которых
# она была вызвана, т.е. перед выходом из блока, мьютекс будет отпущен.
# Отметим, что иного метода освободить блокировку в perl не существует.
#

@threads = ();
my $total : shared = 0;

sub calc {
    while (1) {
        my $result;
        {
            # Это критическая секция, в которой поток должен единолично
            # распоряжаться разделяемой переменной.
            lock($total);
            $total += $result;
        }
        last if $result == 0;
    }
}

for my $i (1..3) {
    push @threads, threads->create(\&calc);
}

for my $thread (@threads) {
    $thread->join();
}

print("total=$total\n");

# В perl все блокировки являются рекурсивными, что означает, что их можно захватывать,
# в момент, когда они уже захвачены тем же потоком. В этом случае, код блокировки проигнорируется.
#
# Несмотря на гарантированное освобождение блокировки, в perl также нельзя избежать взаимоблокировок,
# поэтому следует следить за порядком блокировки нескольких переменных в каждом потоке.

# СИНХРОНИЗИРОВАННАЯ ОЧЕРЕДЬ
# В perl есть реализация синхронизированной очереди, которая лежит в пакете Thread::Queue. С помощью
# этой сущности вы можете укладывать элементы в очередь не заботясь о синхронизации ввода/вывода
# в/из очереди, так как она будет производиться автоматически.

my $DataQueue = Thread::Queue->new();
my $thr = threads->create(sub {
    while (my $DataElement = $DataQueue->dequeue()) {
        print("Popped $DataElement off from queue\n");
    }
});
$DataQueue->enqueue(12);
$DataQueue->enqueue("a","b","c");
sleep(5);
$DataQueue->enqueue(undef);
$thr->join();
#
# Отметим, что если очередь будет пустой, то поток будет блокирован, пока 
# кто-нибудь не положит в очередь что-нибудь еще. Это позволяет организовать
# естественным образом передачу событий между потоками.
#

# СЕМАФОРЫ
# Это механизм синхронизации, представляющий собой счетчик, который поддерживает операции up() и down().
# Операция up() увеличивает счетчик, а down() уменьшает, причем если при уменьшении счетчик становится
# меньше нуля, то поток блокируется. Семафоры создаются со значением, равным 1. Семафор может быть
# инкрементирован или декрементирован на любое значение, которое передается как параметр функциям up() и down(),
# но без аргумента это всегда единица. Отметим, что up(0) и down(0) эквивалентны вызовам без аргумента.
# Семафор объявлен в пакете Thread::Semaphore.
my $semaphore = Thread::Semaphore->new();
my $GlobalVar : shared = 0;

sub demo_semaphore() {
    my($SubNumber) = @_;
    my $Tries = 3;
    my $LocalCopy;
    sleep 1;
    while ($Tries--) {
        $semaphore->down();
        $LocalCopy = $GlobalVar;
        print "Thread: $SubNumber (Try=$Tries): "
        ."\$GlobalVar is $GlobalVar\n";
        sleep(2);
        $LocalCopy++;
        $GlobalVar = $LocalCopy;
        $semaphore->up();
    }
}

@threads = ();
for my $i (1..3) {
    push @threads, threads->create(\&demo_semaphore, $i);
}

for my $thread (@threads) {
    $thread->join();
}
# В этом примере мы привели аналог мьютекса, но только через семафор: только один поток может
# изменять глобальную переменную в каждый момент времени.
# Однако, в каком порядке потоки будут запущены, зависит от настройки и текущего состояния операционной системы.
#
# Основной целью семафоров является упорядочивание доступа многих потоков к ресурсам, упорядочивание
# исполнения потоков. Классическими примерами применения семафоров являются барьеры (несколько потоков собираются в одной
# точке, чтобы затем вместе продолжить работу по сигналу), условные переменные (один поток блокируется
# до наступления некоторого события, о котором его оповестит другой поток в будущем), блокировки чтения/записи (разрешается
# читать ресурс многим потокам, но писать в него может только один).
#

# УСЛОВНЫЕ ПЕРЕМЕННЫЕ
# Условные переменные уже реализованы в perl, поэтому не придется их реализовывать самостоятельно.
# Для этого используются функции cond_wait() и cond_signal().
# Функции cond_wait() передается ранее захваченная переменная в качестве параметра. Затем
# она освободит ее, а затем опять захватит и заблокирует поток до тех пор, пока он не получит
# сигнал от одной из функций cond_signal или cond_broadcast.
#

# ПЕРЕДАЧА УПРАВЛЕНИЯ
# Поток может добровольно отдать управление процессором операционной системе с помощью функции
# yield(), если он решит, что исполняется слишком долго или что ему нечего сейчас делать.

sub loop {
    my $thread = shift;
    my $foo = 10;
    while ($foo--) { print "In thread $thread\n"; }
    threads->yield();
    $foo = 10;
    while ($foo--) { print "In thread $thread\n"; }
}

@threads = ();
for my $i (1..3) {
    push @threads, threads->create(\&loop, $i);
}

for my $thread (@threads) {
    $thread->join();
}

# ПОЛУЧЕНИЕ ИНФОРМАЦИИ О ПОТОКАХ
# Каждый поток может запросить созданный на себя объект с помощью функции
# threads->self(). Этот объект можно сравнить с помощью функции equal() с другим объектом.
# Чтобы узнать идентификатор потока, можно вызвать функцию tid()
# threads->tid(). Главный поток всегда имеет идентификатор 0.
# Список запущенных потоков может быть получен через threads->list(). В этом списке не будет
# главного потока, потому что по умолчанию он находится в отсоединенном состоянии.
#
# Если некоторые потоки не завершились до завершения основного потока, будет выведено предупреждение.
#

# Этот пример демонстрирует многопоточный поиск простых чисел (в данном примере в диапазоне от 3 до 1000).
sub check_num {
    my ($upstream, $cur_prime) = @_;
    my $kid;
    my $downstream = Thread::Queue->new();
    while (my $num = $upstream->dequeue()) {
        next unless ($num % $cur_prime);
        if ($kid) {
            $downstream->enqueue($num);
        } else {
            print("Found prime: $num\n");
            $kid = threads->create(\&check_num, $downstream, $num);
            if (! $kid) {
                warn("Sorry.  Ran out of threads.\n");
                last;
            }
        }
    }
    if ($kid) {
        $downstream->enqueue(undef);
        $kid->join();
    }
}

my $stream = Thread::Queue->new(3..1000, undef);
check_num($stream, 2);

0;
